# VM as a Tool for Memory Management
# 虚拟内存作为内存管理的工具

在上一节中，我们看到虚拟内存是如何提供一种机制，利用 DRAM 缓存来自通常更大的虚拟地址空间的页面。

*DRAM（动态随机存取内存）*是一种常见的计算机内存类型，它用于存储和检索计算机系统的数据。
在虚拟内存系统中，DRAM充当物理内存，用于存储当前活跃或者经常访问的数据和程序代码。虚拟内存系统通过将磁盘存储空间映射到地址空间，允许计算机表现出比实际安装的物理内存（如DRAM）更大的内存容量。

在这个系统中，操作系统将虚拟地址空间分割成称为“页面”的块，并将这些页面存储在硬盘或其他存储设备上。
当需要特定页面时，它会被加载到DRAM中。如果DRAM空间不足，操作系统会根据需要将不常用的页面移回硬盘，以便为新的页面腾出空间。这种机制使得计算机可以有效地运行那些其所需内存超过物理内存容量的大型程序或多个程序。

有趣的是，一些早期的系统，比如 DEC PDP-11/70，支持的是一个比物理内存更小的虚拟地址空间。然而，虚拟地址仍然是一个有用的机制，因为它大大地简化了内存管理，并提供了一种自然的保护内存的方法。

到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。图 9-9 展示了基本思想。在这个示例中，进程 i 的页表将 VP 1 映射到 PP 2，VP 2 映射到 PP 7。相似地，进程 j 的页表将 VP 1 映射到 PP 7，VP 2 映射到 PP 10。注意，多个虚拟页面可以映射到同一个共享物理页面上。

`VM`如何为进程提供独立的地址空间。操作系统为系统中的每个进程都维护一个独立的页表

按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，`VM` 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。


  - **简化链接**。
  独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。
  例如，像我们在图 8-13 中看到的，一个给定的 Linux 系统上的每个进程都使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 `0x400000` 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空间最高的部分，并向下生长。
  这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。

    Here's an ASCII representation of the process address space in a 64-bit Linux system:

    ```s
    +-----------------------------------------+
    | 64-bit Linux Process Address Space      |
    |                                         |
    | 0xFFFFFFFFFFFFFFFF                       |
    | +------------------+                    |
    | | Stack            |                    |
    | | (Grows Downward) |                    |
    | +------------------+                    |
    | |                  |                    |
    | |                  |                    |
    | |                  |                    |
    | |                  |                    |
    | |                  |                    |
    | |      Free        |                    |
    | |      Memory      |                    |
    | |                  |                    |
    | |                  |                    |
    | +------------------+                    |
    | | Heap             |                    |
    | | (Grows Upward)   |                    |
    | +------------------+                    |
    | | BSS              |                    |
    | +------------------+                    |
    | | Data             |                    |
    | +------------------+                    |
    | | Text (Code)      |                    |
    | | 0x400000         |                    |
    | +------------------+                    |
    |                                         |
    +-----------------------------------------+
    ```

    This diagram illustrates the layout of a process's address space in a Linux system with a 64-bit address space:

    - **Text (Code)**: Starts at virtual address `0x400000`.
    - **Data**: Follows the code segment, separated by a required alignment gap.
    - **BSS**: Uninitialized data segment.
    - **Heap**: Grows upward, used for dynamic memory allocation.
    - **Free Memory**: Unused space within the address space.
    - **Stack**: Occupies the highest part of the user process address space and grows downward.

    This consistent format simplifies the design and implementation of linkers, allowing the generation of fully-linked executables that are independent of the final location of code and data in physical memory.

  - **简化加载**。
  虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 `.text` 和 `.data` 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。
  有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是 CPU 取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。
  将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。
  Linux 提供一个称为 `mmap` 的系统调用，允许应用程序自己做内存映射。我们会在 9.8 节中更详细地描述应用级内存映射。
====================================================================================================
当Linux加载器（如`ld.so`对于动态链接的执行文件或`execve`系统调用对于静态链接的执行文件）加载一个程序时，它需要在进程的虚拟地址空间中为程序的代码和数据段分配内存。这一步涉及到虚拟内存管理，特别是虚拟页的概念和页表的操作。下面详细讲述这一步：

### 虚拟内存和页

1. **虚拟内存**：Linux使用虚拟内存管理进程的地址空间。虚拟内存被划分为称为“页”的固定大小的块（通常是4KB）。每个进程都有自己的虚拟地址空间，与物理内存分离。

2. **页表**：页表是操作系统用来管理虚拟页与物理内存之间映射的数据结构。每个进程都有自己的页表。

### 加载器的操作

1. **分配虚拟页**：当加载器加载一个程序时，它首先为程序的代码段和数据段在虚拟地址空间中分配足够的页。这些页最初是空的，没有对应的物理内存。

2. **标记为无效**：加载器将这些新分配的页标记为“无效”。这意味着这些页当前没有存储在物理内存中，也没有被缓存。在这个阶段，虚拟页只是预留了地址空间，但没有实际内容。

3. **页表条目**：加载器接着更新页表，为这些虚拟页创建条目。每个条目包含了虚拟页的信息，包括它们应该映射到文件中的哪个位置。这些条目指向目标文件（例如，可执行文件或共享库）中适当的位置。

### 懒惰加载（Lazy Loading）

通常，Linux加载器采用一种称为“懒惰加载”的策略来处理代码和数据段。这意味着：

- **页内容的延迟加载**：虚拟页的实际内容不是在程序启动时就加载，而是在程序运行时第一次访问这些页时才加载。

- **缺页中断**：当程序尝试访问一个标记为无效的页时，会发生缺页中断。操作系统响应这个中断，将文件中相应的内容加载到物理内存中的某个页，并更新页表，将虚拟页映射到这个新加载的物理页。

通过这种方式，Linux加载器可以有效地管理内存，只在需要时加载程序的部分内容。这不仅节省了内存资源，也加快了程序的启动时间。

### 示例：加载一个简单的Linux程序

假设我们有一个简单的Linux程序，它包含以下部分：

1. **代码段（Code Segment）**：包含程序的可执行指令。
2. **数据段（Data Segment）**：包含程序的全局变量和静态变量。

当这个程序启动时，Linux加载器（如`execve`系统调用）执行以下步骤：

#### 步骤 1: 创建进程和虚拟地址空间

- 操作系统为程序创建一个新进程。
- 为这个进程分配一个虚拟地址空间，这个地址空间只对该进程可见。

#### 步骤 2: 分配虚拟页

- 加载器在虚拟地址空间中为程序的代码段和数据段分配虚拟页。例如：
  - 假设代码段需要3页（每页4KB），加载器将为它们预留一段连续的虚拟地址空间。
  - 假设数据段需要2页，它们也同样被分配到虚拟地址空间中。

#### 步骤 3: 标记虚拟页为无效

- 这些虚拟页最初是空的，即没有映射到物理内存上。
- 加载器将这些页标记为无效，意味着它们尚未被载入物理内存。

#### 步骤 4: 设置页表条目

- 加载器在页表中为这些虚拟页创建条目。
- 这些条目指定了每个虚拟页应当从可执行文件中哪个位置加载数据。

### 程序执行和懒惰加载

- 当程序开始执行并访问代码段的一部分时（比如第一个函数的指令），操作系统会发现这部分代码还未载入物理内存（因为相应的虚拟页被标记为无效）。
- 这会触发一个缺页中断。操作系统响应这个中断，找到代码段在文件中的相应位置，将其加载到物理内存的某个页中，并更新页表，将相应的虚拟页映射到这个新加载的物理页。
- 现在，当程序再次访问这部分代码时，它可以直接从物理内存中获取，而无需再次触发缺页中断。
- 同样的过程也适用于数据段。当程序第一次访问其全局变量或静态变量时，相关数据页会被加载到物理内存中。

通过这种方法，Linux加载器有效地只加载程序需要的内存部分，从而节省资源并提高效率。
====================================================================================================
  - **简化共享**。
  独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。

然而，在一些情况中，还是需要进程来共享代码和数据。
例如，每个进程必须调用相同的操作系统内核代码，而每个 C 程序都会调用 C 标准库中的程序，比如 `printf`。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和 C 标准库的副本。

 - **简化内存分配**。
 虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用 `malloc` 的结果），操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。页面可以随机地分散在物理内存中。

虚拟内存极大地简化了内存分配的过程，特别是在用户进程请求额外的堆空间时。这一过程的简化主要体现在以下几个方面：

### 1. 提供连续的虚拟地址空间

虚拟内存为进程提供一个连续的地址空间，即使物理内存是分散的。当程序请求更多的堆空间（例如，通过 `malloc` 调用），操作系统可以轻松地在这个连续的虚拟地址空间中分配内存，而不用担心物理内存的实际布局。

### 2. 灵活的物理内存分配

由于操作系统使用页表来映射虚拟地址到物理地址，它不需要在物理内存中找到连续的空间来满足这些请求。相反，它可以选择任意的、分散的物理页面来映射到所请求的连续虚拟内存页。这种灵活性简化了内存的管理和分配。

### 3. 易于管理的堆空间

在虚拟内存系统中，堆空间的管理变得更加简单。操作系统可以根据需要动态地增加或减少分配给进程的堆空间，而不需要进行复杂的物理内存重组或移动数据。

### 4. 降低内存碎片化

在没有虚拟内存的系统中，内存碎片化是一个常见问题，因为连续的物理内存块可能不可用。虚拟内存通过允许非连续的物理内存分配，有效地减少了内存碎片化的问题。

### 5. 改善性能和扩展性

虚拟内存提高了系统的整体性能和扩展性。它使得操作系统可以支持比实际物理内存更大的地址空间，从而允许更大或更多的应用程序同时运行。



====================================================================================================
为了实践验证这个过程，你可以执行以下步骤，这将涉及编写一个简单的程序、观察其内存映射以及监控对应的页载入行为：

### 步骤 1: 编写一个简单的程序

首先，你需要一个简单的程序，以便于跟踪和观察。这个程序可以包含一些基本的代码和数据，例如：

```c
#include <stdio.h>

int globalVar = 0; // 全局变量，将在数据段中

void printHello() {
    printf("Hello, World!\n"); // 函数，将在代码段中
}

int main() {
    printHello();
    globalVar = 5;
    printf("Global variable value: %d\n", globalVar);
    return 0;
}
```

将这段代码保存为 `example.c` 并使用 `gcc` 编译：

```bash
gcc example.c -o example
```

### 步骤 2: 观察程序的内存映射

使用 `pmap` 命令来观察程序的内存映射。在程序运行时，在另一个终端窗口执行：

```bash
pmap [PID]
```

这里的 `[PID]` 是你的程序的进程ID。你可以使用 `ps` 或 `top` 命令找到这个ID。`pmap` 将显示进程的内存映射，包括代码段和数据段。

### 步骤 3: 使用 strace 跟踪系统调用

`strace` 是一个强大的工具，可以用来跟踪一个进程的所有系统调用，包括内存映射相关的调用。使用以下命令运行你的程序：

```bash
strace ./example
```

这将显示所有由程序触发的系统调用，包括 `mmap`。

### 步骤 4: 使用 perf 工具

`perf` 是一个性能分析工具，它可以用来监控程序运行时的各种事件，包括页面错误。使用以下命令来监控你的程序：

```bash
perf stat -e page-faults ./example
```

这将显示程序运行过程中发生的页面错误次数，这些错误通常是由于懒惰加载引起的。

~~~shell
czy@czy-307-thinkcentre-m720q-n000 Virtual_Memory/04 (master *%) » perf stat -e page-faults ./example                         

Hello, World!
Global variable value: 5

 Performance counter stats for './example':

                53      page-faults                                                 

       0.002085992 seconds time elapsed

       0.002051000 seconds user
       0.000000000 seconds sys
~~~

### 额外的实验

- **修改并重新编译**：你可以修改程序，例如增加数据的使用或改变代码的结构，然后重新编译并观察这些变化如何影响内存映射和页载入。

- **内存访问模式**：你可以编写不同的内存访问模式，比如只访问数据段而不执行任何代码，或者相反，然后使用上述工具观察结果的不同。

通过这些步骤，你可以亲身体验和验证Linux加载器如何为程序的代码和数据段分配虚拟页，以及操作系统如何在程序运行时将这些页映射到物理内存。  


~~~shell
gef➤  info proc mappings
process 142455
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /home/czy/new_space/Virtual_Memory/04/example
      0x555555555000     0x555555556000     0x1000     0x1000 /home/czy/new_space/Virtual_Memory/04/example
      0x555555556000     0x555555557000     0x1000     0x2000 /home/czy/new_space/Virtual_Memory/04/example
      0x555555557000     0x555555558000     0x1000     0x2000 /home/czy/new_space/Virtual_Memory/04/example
      0x555555558000     0x555555559000     0x1000     0x3000 /home/czy/new_space/Virtual_Memory/04/example
      0x555555559000     0x55555557a000    0x21000        0x0 [heap]
      0x7ffff7dbd000     0x7ffff7ddf000    0x22000        0x0 /usr/lib/x86_64-linux-gnu/libc-2.31.so
      0x7ffff7ddf000     0x7ffff7f57000   0x178000    0x22000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
      0x7ffff7f57000     0x7ffff7fa5000    0x4e000   0x19a000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
      0x7ffff7fa5000     0x7ffff7fa9000     0x4000   0x1e7000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
      0x7ffff7fa9000     0x7ffff7fab000     0x2000   0x1eb000 /usr/lib/x86_64-linux-gnu/libc-2.31.so
      0x7ffff7fab000     0x7ffff7fb1000     0x6000        0x0 
      0x7ffff7fc9000     0x7ffff7fcd000     0x4000        0x0 [vvar]
      0x7ffff7fcd000     0x7ffff7fcf000     0x2000        0x0 [vdso]
      0x7ffff7fcf000     0x7ffff7fd0000     0x1000        0x0 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7fd0000     0x7ffff7ff3000    0x23000     0x1000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ff3000     0x7ffff7ffb000     0x8000    0x24000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x2c000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x2d000 /usr/lib/x86_64-linux-gnu/ld-2.31.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
~~~

# 查看一个进程的地址空间
要查看一个 ELF（Executable and Linkable Format）程序的进程地址空间，你可以使用几种不同的工具和方法。以下是一些常用的方式：

### 1. 使用 `pmap`

`pmap` 是一个显示Linux进程的内存映射的工具。它提供了关于进程地址空间的详细信息，包括每个映射的开始地址、大小、权限、偏移量以及映射到的文件。

- **运行程序**：首先，运行你的 ELF 程序。
- **找出进程ID**：使用 `ps` 或 `top` 命令找出你的程序的进程ID。
- **使用 `pmap`**：然后，使用 `pmap` 命令查看该进程的地址空间：

  ```bash
  pmap [PID]
  ```

  这里的 `[PID]` 是你的程序的进程ID。

### 2. 使用 `gdb`

`gdb` 是GNU调试器，可以用来调试程序并检查其运行时的内存布局。

- **启动 `gdb`**：使用 `gdb` 启动你的程序：

  ```bash
  gdb ./your_program
  ```

- **运行程序**：在 `gdb` 里运行你的程序（输入 `run`）。
- **查看映射**：在程序暂停或结束时，使用 `info proc mappings` 命令查看进程的内存映射。

### 3. 使用 `/proc` 文件系统

Linux 的 `/proc` 文件系统包含了关于运行中的进程的信息，包括它们的内存映射。

- **查看映射**：你可以直接查看 `/proc/[PID]/maps` 文件，其中 `[PID]` 是你的程序的进程ID。例如：

  ```bash
  cat /proc/[PID]/maps
  ```

这将显示进程的虚拟地址空间的布局，包括不同段的起始和结束地址、权限等。

### 注意事项

- 这些方法通常需要你能够访问对应的进程ID，这意味着你需要有权限访问该进程的信息。
- 如果你的程序很快执行完毕，你可能需要在程序中添加暂停（例如等待用户输入），以便有时间来观察其内存布局。

====================================================================================================

# 如何快速获取一个进程的PID

要快速获取一个进程的 PID（Process ID），有多种方法可以根据不同的操作系统和具体情况来选择。以下是一些常用的方法：

### 1. 使用 `ps` 命令

在 Unix-like 系统中，`ps` 命令用于显示当前运行的进程。你可以结合 `grep` 来查找特定进程的 PID。例如，要找到名为 "example" 的进程的 PID：

```bash
ps aux | grep example
```

这将列出所有名为 "example" 的进程及其详细信息，包括 PID。

~~~shell
czy-307-thinkcentre-m720q-n000 :: ~/new_space/Virtual_Memory » ps aux | grep example
czy       142706  2.1  0.7  78604 61148 pts/3    S+   23:28   0:00 gdb ./example
czy       142738  0.0  0.0   2496   712 pts/3    t    23:28   0:00 /home/czy/new_space/Virtual_Memory/04/example
czy       142831  0.0  0.0  12136   724 pts/4    S+   23:28   0:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn --exclude-dir=.idea --exclude-dir=.tox example
~~~

### 2. 使用 `pgrep`

`pgrep` 是一个更专门的工具，用于查找匹配特定条件的进程的 PIDs。使用 `pgrep` 可以直接返回 PID，而无需额外的处理：

```bash
pgrep example
```

这将返回所有名为 "example" 的进程的 PID。

~~~shell
czy-307-thinkcentre-m720q-n000 :: ~/new_space/Virtual_Memory » pgrep example
142738
~~~

### 3. 使用 `pidof`

`pidof` 命令是用来查找某个特定命令的 PID 的。例如：

```bash
pidof example
```

~~~shell
czy-307-thinkcentre-m720q-n000 :: ~/new_space/Virtual_Memory » pidof example
142738
~~~

这将返回所有 "example" 命令的 PID。

### 注意事项

- 替换 "example" 为你要查找的实际进程名。
- 某些进程可能需要管理员权限才能查看。
- 在使用 `grep` 或 `findstr` 时，它们会匹配所有包含指定字符串的进程名，所以请确保你的搜索关键字尽可能唯一以避免混淆。