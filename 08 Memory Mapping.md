# Memory Mapping
# 内存映射

Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object）关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory mapping），虚拟内存区域可以映射到两种类型的对象中的一种：

 1. `Linux 文件系统中的普通文件`：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。
 文件区（`section`）被分成页大小的片，每一片包含一个虚拟页面的初始内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到 CPU 第一次引用到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。

 2. `匿名文件`: 一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。
 CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。
 注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件的区域中的页面有时也叫做请求二进制零的页（`demand-zero page`）。

 无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件（`swap file`）之间换来换去。
 交换文件也叫做交换空间（`swap space`）或者交换区域（`swap area`）。
 需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。

====================================================================================================
这句话描述了操作系统中虚拟内存管理的一个重要概念，即如何使用交换文件（`swap file`）或交换空间（`swap space`）来管理内存。
下面是对这个概念的详细解释：

1. **虚拟页面的初始化**：
   - 当一个程序运行时，操作系统分配给它一定量的虚拟内存，这个内存被分成多个虚拟页面。
   - 一旦这些虚拟页面被初始化（即被分配并可能被程序使用），它们就开始参与虚拟内存管理的过程。

2. **交换文件/空间的作用**：
   - 交换文件（在一些操作系统中也称为交换空间或交换区域）是硬盘上的一个专用文件或分区，用于存储不常用的虚拟内存页面。
   - 当物理内存（RAM）接近满载时，操作系统会选择一些当前不活跃或不常用的内存页面，并将它们移动到交换空间中，释放物理内存。
   - 这个过程称为“交换”（swapping）或“分页”（paging）。

3. **交换的动态过程**：
   - 虚拟页面在物理内存和交换文件之间的移动是动态的。根据系统的内存需求和页面的使用情况，操作系统不断地在物理内存和交换空间之间移动页面。
   - 如果一个在交换文件中的页面需要被访问，操作系统会将其重新载入到物理内存中，这个过程可能导致其他页面被移动到交换空间。

4. **交换空间的限制**：
   - 交换空间的大小限制了可以分配给进程的虚拟内存的总量。尽管虚拟内存理论上可以非常大，但实际上它受限于物理内存和交换空间的总和。
   - 如果交换空间太小，那么在内存需求高的情况下可能无法有效地分配和管理虚拟内存，从而影响系统性能。

5. **系统性能影响**：
   - 依赖过多的交换操作可能会导致性能下降，因为硬盘访问速度远低于RAM。
   - 因此，虽然交换机制允许系统运行更多的程序，但过度使用交换空间会导致所谓的“交换颠簸”（`swap thrashing`），即系统花费大量时间在交换操作上，而不是有效地运行程序。

总的来说，交换空间是虚拟内存管理的重要组成部分，它允许操作系统更灵活地分配内存资源，但它的大小和使用效率对系统性能有重要影响。


交换空间（swap space）是操作系统内存管理的一个关键组成部分，主要用于以下几个目的：
1. **扩展物理内存**：
   - 交换空间允许操作系统使用硬盘空间作为虚拟内存，从而扩展了可用于程序和数据的内存量。这对于物理内存（RAM）有限的系统尤其重要。
2. **防止内存耗尽**：
   - 当物理内存的使用接近上限时，操作系统可以将不常使用的数据（通常是那些被加载到内存中但暂时未被访问的部分）移到交换空间中，从而为新的应用程序或数据腾出空间。这有助于防止系统因内存耗尽而崩溃。
3. **内存管理的灵活性**：
   - 使用交换空间可以提高内存管理的灵活性。操作系统可以根据需要动态地在物理内存和交换空间之间移动数据，优化内存使用。
4. **支持休眠模式**：
   - 在一些操作系统中，交换空间也用于实现休眠（hibernation）功能。在休眠过程中，系统的当前状态（包括所有内存内容）被保存到交换空间中，然后电源关闭。重新启动时，系统状态从交换空间恢复，恢复到关闭前的状态。
5. **性能优化**：
   - 虽然交换操作相比于直接内存访问要慢，但合理使用交换空间可以优化整体系统性能。例如，通过将不活跃的进程移至交换空间，可以为当前活跃的进程提供更多的物理内存资源。
6. **成本效益**：
   - 物理内存（尤其是大容量内存）的成本通常高于硬盘空间。因此，使用交换空间作为额外的虚拟内存是一种成本效益较高的解决方案。

然而，需要注意的是，交换空间的使用应当谨慎。由于硬盘的读写速度远低于RAM，过度依赖交换空间（尤其是在高内存需求的情况下）可能导致系统性能显著下降。理想情况下，交换空间应该作为物理内存的补充，而不是替代。

`“交换空间的大小限制了可以分配给进程的虚拟内存的总量。尽管虚拟内存理论上可以非常大，但实际上它受限于物理内存和交换空间的总和`
这句话描述的是虚拟内存系统中物理内存和交换空间对可分配虚拟内存总量的限制。
在现代操作系统中，虚拟内存是一种重要的内存管理技术，它允许程序超出物理内存的限制进行数据存储。然而，虚拟内存的实际大小并不是无限的，而是受到以下因素的限制：
1. **物理内存（RAM）**：
   - 物理内存是计算机直接访问的内存。它的大小直接限制了可以立即访问的数据量。
   - 虽然虚拟内存允许操作系统超出这个限制，但物理内存的大小仍然是一个重要因素，因为它影响了系统在不进行交换时能处理的数据量。
2. **交换空间（Swap Space）**：
   - 交换空间是硬盘上的一部分，用作额外的虚拟内存。当物理内存不足时，操作系统可以将内存中不活跃的数据页交换到硬盘上的交换空间。
   - 交换空间的大小加上物理内存的大小共同构成了操作系统能够提供的最大虚拟内存空间。这意味着即使操作系统和处理器能够支持更大的虚拟内存空间，如果物理内存和交换空间的总和有限，可用的虚拟内存也将受到限制。
3. **虚拟内存的总和**：
   - 因此，虚拟内存的实际大小是物理内存和交换空间大小的总和。这是因为虚拟内存系统通过在物理内存和交换空间之间移动数据来管理内存。
   - 例如，如果一个系统有 8GB 的物理内存和 8GB 的交换空间，那么最多可以分配 16GB 的虚拟内存给进程。
4. **系统性能考虑**：
   - 虽然增加交换空间可以提高可用的虚拟内存总量，但由于交换空间位于硬盘上，其访问速度远低于物理内存，因此过度依赖交换空间可能会导致性能问题。
总的来说，这句话强调了虽然虚拟内存技术允许操作系统超越物理内存的限制，但实际可用的虚拟内存量仍然受到物理内存和交换空间总量的限制。

`需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数`
这句话的意思是，操作系统中的交换空间（Swap Space）决定了可以分配给运行中的进程的虚拟内存页面的最大数量。
为了更好地理解这一点，我们需要探讨几个关键概念：
1. **虚拟内存**：
   - 虚拟内存是一种内存管理能力，它使得操作系统能够为每个进程提供一个看似独立和连续的内存空间，这个空间被分割成多个虚拟页面。
   - 这种技术允许操作系统超越物理内存（RAM）的限制，通过使用硬盘空间作为额外的内存资源。
2. **交换空间的作用**：
   - 交换空间是硬盘上的一部分，被操作系统用作额外的虚拟内存。当物理内存不足以容纳所有活跃的虚拟页面时，操作系统会将一些页面移到交换空间，从而释放物理内存。
   - 这意味着交换空间充当了虚拟内存的一个重要组成部分，尤其是在物理内存使用接近饱和时。
3. **限制因素**：
   - 虽然理论上每个进程都可以获得相当大的虚拟内存空间，但实际上，这个空间的大小是受限于物理内存和交换空间总和的。
   - 交换空间的大小直接影响到系统可以为进程分配多少虚拟内存。如果交换空间有限，那么即使物理内存未完全使用，可用的虚拟内存也会受到限制。
4. **虚拟页面分配**：
   - 在操作系统中，虚拟内存被分配给进程，而这些内存又被分割成虚拟页面。每个虚拟页面都可以独立地映射到物理内存或交换空间中。
   - 当交换空间不足时，操作系统将无法分配更多的虚拟页面给进程，即使这些进程实际上并没有使用它们映射的物理内存。
   - 这就是为什么交换空间的大小会限制当前运行的进程能够分配的虚拟页面总数。

因此，“交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数”是指操作系统中交换空间的容量决定了能够提供给进程的总虚拟内存量。
为了确保系统性能和稳定性，操作系统需要在物理内存和交换空间之间有效地管理虚拟内存。
====================================================================================================

# 再看共享对象
内存映射的概念来源于一个聪明的发现：如果虚拟内存系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中的方法。

内存映射（`Memory Mapping`）是一种有效的文件数据处理技术，它的核心思想是将`文件的内容直接映射到进程的虚拟内存空间`。
这种方法的提出基于一个重要的认识：如果虚拟内存系统能够与传统的文件系统紧密集成，就可以提供一种简单且高效的方法，将程序和数据加载到内存中。以下是对内存映射的详细解释：

1. **虚拟内存系统与文件系统的集成**：
   - 在传统的文件系统操作中，数据通常通过读写系统调用在磁盘文件和进程的内存空间之间传输。
   - 内存映射通过虚拟内存系统与文件系统的集成，简化了这个过程。
   它允许将磁盘上的文件直接映射到进程的虚拟地址空间，就好像文件数据已经在内存中一样。

2. **文件映射到内存的过程**：
   - 当文件被映射到内存时，操作系统创建了一个虚拟地址空间，其中的地址直接对应于文件中的数据。
   - 这意味着程序可以通过指针操作来读写文件，就像访问常规内存那样，无需显式的读写调用。

3. **延迟加载（Demand Paging）**：
   - 通常情况下，文件不会立即完全加载到物理内存中。
   而是采用延迟加载（或按需分页）的方式，当程序访问到某部分数据时，相应的文件区域才被加载到物理内存中。
   - 这种方法提高了内存使用效率，特别是对于大文件或仅部分访问的情况。

4. **性能提升**：
   - 内存映射提供了一种高效的数据访问方式，因为它减少了数据在用户空间和内核空间之间的复制需要，从而降低了`I/O`操作的开销。
   - 对于频繁读写的应用，这可以显著提升性能。

5. **适用场景**：
   - 内存映射特别适用于需要频繁且随机访问大文件的应用程序。例如，数据库系统经常使用内存映射来提高数据访问速度。

综上所述，内存映射是基于将虚拟内存系统与文件系统集成这一聪明的发现而发展起来的。
它通过直接映射文件到进程的虚拟内存，简化了文件数据的处理方式，同时提高了数据访问的效率和性能。
====================================================================================================

正如我们已经看到的，进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。
不过，许多进程有同样的只读代码区域。例如，每个运行 Linux shell 程序 bash 的进程都有相同的代码区域。
而且，许多程序需要访问只读运行时库代码的相同副本。例如，每个 C 程序都需要来自标准 C 库的诸如 printf 这样的函数。那么，如果每个进程都在物理内存中保持这些常用代码的副本，那就是极端的浪费了。
幸运的是，内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。

一个对象可以被映射到虚拟内存的一个区域，要么作为`共享对象`，要么作为`私有对象`。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。
而且，这些变化也会反映在磁盘上的原始对象中。

另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做共享区域。类似地，也有私有区域。

====================================================================================================
这段话描述的是内存映射中"私有"（`Private`）与"共享"（`Shared`）映射区域的概念及其行为差异。
这两种映射模式决定了当多个进程映射同一个文件时，它们如何相互影响。以下是对这些概念的详细解释：

### 私有区域（Private Mapping）
1. **定义**：
   - 当一个文件或数据对象被映射到进程的虚拟内存空间作为私有区域时，该进程对映射区域的更改只对自己可见，对其他映射了同一文件的进程不可见。
2. **行为**：
   - 对私有映射区域的写操作不会反映到磁盘上的原始文件中。这是因为私有映射在写入时采用“写时复制”（`Copy-On-Write`, COW）机制。
   - 在COW机制下，当进程尝试写入映射区域时，操作系统会创建该区域的一个副本。因此，写操作只修改这个副本，而不是原始文件或其他进程的映射。
3. **用途**：
   - 私有映射适用于需要读取文件内容但不想或不需要将更改反映到原始文件中的场景。

### 共享区域（Shared Mapping）
1. **定义**：
   - 共享映射区域是当一个文件或数据对象被映射到多个进程的虚拟内存空间时，这些进程之间共享对该区域的读写访问。
2. **行为**：
   - 在共享映射中，一个进程对映射区域所做的更改对所有映射了同一文件的进程可见。
   - 如果一个进程修改了共享映射区域的内容，这些更改也会反映到磁盘上的原始文件中。
3. **用途**：
   - 共享映射适用于需要多个进程共享和修改同一数据集的情况，例如在进程间共享内存的应用程序。

### 总结
- **私有区域**：
  - 更改仅对本进程可见。
  - 写操作不影响原始文件。
  - 使用“写时复制”机制。
- **共享区域**：
  - 更改对所有映射该文件的进程可见。
  - 写操作会更新原始文件。
理解这两种映射方式的不同特性对于高效和正确地使用内存映射非常重要，尤其是在涉及文件数据共享和多进程通信的应用程序中。
====================================================================================================

假设进程 1 将一个共享对象映射到它的虚拟内存的一个区域中，如图 9-29a 所示。
现在假设进程 2 将同一个共享对象映射到它的地址空间（并不一定要和进程 1 在相同的虚拟地址处，如图 9-29b 所示）。

因为每个对象都有一个唯一的文件名，内核可以迅速地判定进程 1 已经映射了这个对象，而且可以使进程 2 中的页表条目指向相应的物理页面。
关键点在于即使对象被映射到了多个共享区域，物理内存中也只需要存放共享对象的一个副本。
为了方便，我们将物理页面显示为连续的，但是在一般情况下当然不是这样的。

# copy-on-write
私有对象使用一种叫做写时复制（`copy-on-write`）的巧妙技术被映射到虚拟内存中。
一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理内存中只保存有私有对象的一份副本。比如，图 `9-30a` 展示了一种情况，其中两个进程将一个私有对象映射到它们虚拟内存的不同区域，但是共享这个对象同一个物理副本。
对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，`并且区域结构被标记为私有的写时复制`。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。

当故障处理程序注意到保护异常是由于`进程试图写私有的写时复制区域`中的一个页面而引起的，它就会在**物理内存**中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限，如图 9-30b 所示。
当故障处理程序返回时，CPU 重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。

通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了**稀有**的物理内存。

# 再看 `fork()` 函数

既然我们理解了虚拟内存和内存映射，那么我们可以清晰地知道 fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的。

当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。

为了给这个新进程创建虚拟内存，它创建了当前进程的 `mm_struct`、`区域结构`和`页表`的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。

当 fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同。
当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。

您的描述准确地概述了 `fork()` 函数在现代操作系统中如何利用虚拟内存和内存映射技术来创建进程。以下是这个过程的详细解释：

### `fork()` 创建新进程的过程

1. **创建进程和分配 PID**：
   - 当一个进程调用 `fork()` 时，操作系统首先为新的子进程创建各种必要的内核数据结构，并分配一个唯一的进程标识符（PID）。
2. **复制虚拟内存结构**：
   - 操作系统复制父进程的 `mm_struct`（内存管理结构），这包含了虚拟地址空间的定义、权限和映射等信息。
   - 它还复制 `区域结构`（定义了虚拟内存中不同区域的属性）和页表（映射虚拟地址到物理地址的结构）。
3. **写时复制（Copy-On-Write, COW）机制**：
   - 在复制过程中，子进程的虚拟内存页并不立即完全复制。相反，父子进程共享相同的物理内存页，并将这些页标记为只读。
   - 同时，区域结构被标记为“写时复制”。这意味着，如果父进程或子进程试图修改这些共享的内存页，操作系统会先为修改者创建这些页的副本，确保每个进程都有自己独立的内存副本，从而维护私有地址空间的概念。
4. **进程独立性**：
   - 当 `fork()` 在新进程中返回时，这个新进程拥有与父进程相同的虚拟内存布局。
   但由于写时复制机制，新进程和父进程的物理内存实际上是独立的。
   - 任何后续的写操作都会触发写时复制，操作系统为写操作的进程创建新的内存页，保持了虚拟地址空间的独立性和一致性。

### 结果和优势

- 这个过程的优势在于，它允许操作系统高效地创建新进程，避免了不必要的数据复制，直到确实需要时才进行。
- 这种方法大大减少了 `fork()` 的开销，特别是对于大型进程。
- 通过写时复制，操作系统保持了每个进程的地址空间私有性和独立性，即使它们起初共享相同的物理内存页。

总之，`fork()` 和写时复制机制结合使用，提供了一种有效的方式来创建新的进程，同时确保了资源的高效使用和进程间的独立性。
====================================================================================================

`fork()` 函数是 Unix 和类 Unix 操作系统（如 Linux）中一个非常重要的系统调用。它用于创建一个新的进程，这个新进程被称为子进程，它是调用 `fork()` 的当前进程（父进程）的副本。

### 工作原理

1. **进程复制**：
   - 当父进程调用 `fork()` 时，操作系统创建一个新的子进程。子进程几乎是父进程的完整副本，拥有与父进程相同的代码和数据段。

2. **内存共享**：
   - 初始时，子进程共享父进程的内存页（使用写时复制技术）。如果父进程或子进程试图修改这些共享页，操作系统会为修改者创建这些页的副本，从而保持父子进程内存的独立性。

3. **返回值**：
   - `fork()` 在父进程中返回新创建的子进程的进程ID（PID），在子进程中返回 0。如果 `fork()` 调用失败，则返回 -1。

### 用途

- **并发执行**：
  - `fork()` 使得程序能够并发执行。父进程可以继续执行原有的任务，而子进程可以独立地执行其他任务或相同的任务。

- **进程间通信**：
  - 通过 `fork()` 创建的子进程可以用于进程间通信（IPC）。父子进程可以通过管道、信号、共享内存等机制进行通信。

- **程序的扩展和替换**：
  - 在很多情况下，`fork()` 与 `exec()` 系列函数结合使用。`fork()` 创建一个新的进程，然后 `exec()` 加载一个新的程序到这个进程中去，从而替换掉原来的程序。这是启动新程序的常用方法。

### 注意事项

- **资源消耗**：
  - `fork()` 创建的进程占用额外的内存和处理器资源。虽然操作系统使用优化（如写时复制），但在资源有限的系统中仍需谨慎使用。

- **僵尸进程**：
  - 如果子进程结束其执行（终止），而父进程未通过 `wait()` 或 `waitpid()` 调用来检索子进程的退出状态，则子进程会成为僵尸进程。僵尸进程消耗系统资源，因此应避免。

- **并发问题**：
  - 因为父子进程可能并发运行，所以必须注意同步和竞态条件的问题。

### 示例

下面是一个简单的 `fork()` 使用示例：

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>

int main() {
    pid_t pid = fork();

    if (pid == -1) {
        // fork() failed
        perror("fork failed");
        return -1;
    } else if (pid > 0) {
        // Parent process
        printf("Parent process, child PID: %d\n", pid);
    } else {
        // Child process
        printf("Child process\n");
    }

    return 0;
}
```

在这个示例中，父进程会打印出子进程的 PID，而子进程会打印一个简单的消息。这演示了 `fork()` 如何在父子进程中返回不同的值。

# 再看 `execve()` 函数

虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。
既然已经理解了这些概念，我们就能够理解 execve 函数实际上是如何加载和执行程序的。
假设运行在当前进程中的程序执行了如下的 `execve` 调用：

~~~c
execve("a.out", NULL, NULL);
~~~

正如在第 8 章中学到的，`execve` 函数在当前进程中加载并运行包含在可执行目标文件 a.out 中的程序，用 a.out 程序有效地替代了当前程序。加载并运行 a.out 需要以下几个步骤：

1. **删除已存在的用户区域** 删除当前进程虚拟地址的用户部分中的已存在的区域结构。
2. **映射私有区域** 为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是**私有的、写时复制**的。
代码和数据区域被映射为 `a.out` 文件中的 `.text` 和 `.data` 区。`bss` 区域是**请求二进制零**的，映射到匿名文件，其大小包含在 `a.out` 中。栈和堆区域也是请求二进制零的，初始长度为零。图 9-31 概括了私有区域的不同映射。
3. **映射共享区域**。如果 `a.out` 程序与共享对象（或目标）链接，比如标准 C 库 `libc.so`，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。
4. **设置程序计数器（PC）**。`execve` 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。
~~~shell

~/new_space/Virtual_Memory (master ✘)✹✭ ᐅ pmap 150339
150339:   ./exam
00005601bf181000      4K r---- exam
00005601bf182000      4K r-x-- exam
00005601bf183000      4K r---- exam
00005601bf184000      4K r---- exam
00005601bf185000      4K rw--- exam
00005601c0060000    132K rw---   [ anon ]
00007faebf02f000    136K r---- libc-2.31.so
00007faebf051000   1504K r-x-- libc-2.31.so
00007faebf1c9000    312K r---- libc-2.31.so
00007faebf217000     16K r---- libc-2.31.so
00007faebf21b000      8K rw--- libc-2.31.so
00007faebf21d000     24K rw---   [ anon ]
00007faebf23b000      4K r---- ld-2.31.so
00007faebf23c000    140K r-x-- ld-2.31.so
00007faebf25f000     32K r---- ld-2.31.so
00007faebf268000      4K r---- ld-2.31.so
00007faebf269000      4K rw--- ld-2.31.so
00007faebf26a000      4K rw---   [ anon ]
00007ffc6d3b0000    132K rw---   [ stack ]
00007ffc6d3e2000     16K r----   [ anon ]
00007ffc6d3e6000      8K r-x--   [ anon ]
ffffffffff600000      4K --x--   [ anon ]
 total             2500K
~~~

下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。

~~~c
#include <unistd.h>
#include <sys/mman.h>

void *mmap(void *start, size_t length, int prot, int flags,
           int fd, off_t offset);

// 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED(-1)。
~~~

`mmap()` 是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，它提供了将文件或设备映射到内存的功能。
这允许程序直接从内存中访问文件或设备的内容，提高了文件访问的效率。下面是对 `mmap()` 函数的详细介绍：

====================================================================================================

### 函数原型

```c
#include <unistd.h>
#include <sys/mman.h>

void *mmap(void *start, size_t length, int prot, int flags,
           int fd, off_t offset);
```

- **`start`**：期望映射区域的起始地址。通常设置为 `NULL`，表示让操作系统选择映射的地址。
- **`length`**：映射区域的长度。这个长度是以字节为单位的，它决定了文件的多少内容被映射到内存。
- **`prot`**：映射区域的保护方式。它可以是以下几个值的组合：
  - `PROT_READ`：可读
  - `PROT_WRITE`：可写
  - `PROT_EXEC`：可执行
  - `PROT_NONE`：不可访问
- **`flags`**：影响映射区域的各种特性。它可以是以下几个值的组合：
  - `MAP_SHARED`：对映射区域的修改会反映到文件中，并且对其他映射了该文件的进程可见。
  - `MAP_PRIVATE`：建立一个写时复制的私有映射。对映射区域的修改不会反映到文件中。
  - 其他标志如 `MAP_FIXED` 等。
- **`fd`**：要映射到内存的文件的文件描述符。该文件应该已经打开，并且其访问模式与 `prot` 指定的访问权限相兼容。
- **`offset`**：文件中的偏移量，从该处开始映射。*通常需要是系统页面大小的整数倍*。

### 返回值

- `mmap()` 成功时返回指向映射区域的指针。
- 如果出错，则返回 `MAP_FAILED`（其值通常为 `-1`）。

### 使用场景

- **文件访问**：可以用 `mmap()` 将整个文件或文件的一部分映射到内存中，从而提供对文件内容的快速访问。
- **进程间通信**：通过映射同一个文件或共享内存对象，多个进程可以共享数据。
- **设备内存映射**：用于直接从内存访问硬件设备。

### 注意事项

- 在使用完映射后，应该使用 `munmap()` 函数来解除映射。
- 映射时的保护属性应与文件的打开模式兼容。例如，如果文件是只读打开的，那么映射时就不能指定 `PROT_WRITE`。
- 对于 `MAP_SHARED` 类型的映射，如果对映射区域的更改需要写回文件，必须确保文件是以可写方式打开的。

`mmap()` 函数是一种高效的文件和设备内存访问方式，它减少了传统的读写系统调用所需要的数据复制次数，可以显著提高程序的性能。

要使用 ASCII 绘制 `mmap()` 函数参数的可视化解释，我们可以创建一个简单的图表来展示每个参数的作用和它们如何相互关联。这里是一个示例：

```
+-----------------------------------------------------------------+
|                        mmap() Function                          |
+------------------+----------------------+-----------------------+
|     Parameter    |        Purpose       |       Description     |
+------------------+----------------------+-----------------------+
| void *start      | 期望的映射起始地址      | 通常设为 NULL，让操作 |
|                  |                      | 系统选择映射地址      |
+------------------+----------------------+-----------------------+
| size_t length    | 映射区域的长度         | 决定映射文件内容的大小|
+------------------+----------------------+-----------------------+
| int prot         | 映射区域的保护方式      | PROT_READ, PROT_WRITE,|
|                  |                      | PROT_EXEC, PROT_NONE  |
+------------------+----------------------+-----------------------+
| int flags        | 映射区域的特性         | MAP_SHARED, MAP_PRIVATE|
|                  |                      | 等                     |
+------------------+----------------------+-----------------------+
| int fd           | 文件描述符            | 要映射的文件描述符    |
+------------------+----------------------+-----------------------+
| off_t offset     | 文件中的偏移量         | 映射起始点在文件中的  |
|                  |                      | 偏移量                |
+------------------+----------------------+-----------------------+
| 返回值           | 映射区域的指针或错误     | 成功时返回指针，失败时|
|                  |                      | 返回 MAP_FAILED       |
+------------------+----------------------+-----------------------+
```

这个表格提供了 `mmap()` 函数每个参数的基本描述，以及它们的作用。希望这能帮助您更好地理解 `mmap()` 函数的参数和用法。

====================================================================================================

`mmap` 函数要求内核创建一个新的虚拟内存区域，最好是从地址 `start` 开始的一个区域，并将文件描述符 `fd` 指定的对象的一个连续的片（`chunk`）映射到这个新的区域。连续的对象片大小为 `length` 字节，从距文件开始处偏移量为 `offset` 字节的地方开始。start 地址仅仅是一个暗示，通常被定义为 NULL。为了我们的目的，我们总是假设起始地址为 NULL。图 9-32 描述了这些参数的意义。

参数 prot 包含描述新映射的虚拟内存区域的访问权限位（即在相应区域结构中的 vm_prot 位）。
`PROT_EXEC`：这个区域内的页面由可以被 CPU 执行的指令组成。
`PROT_READ`：这个区域内的页面可读。
`PROT_WRITE`：这个区域内的页面可写。
`PROT_NONE`：这个区域内的页面不能被访问。

参数 `flags` 由描述被映射对象类型的位组成。如果设置了 `MAP_ANON` 标记位，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。`MAP_PRI-VATE` 表示被映射的对象是一个私有的、写时复制的对象，而 `MAP_SHARED` 表示是一个共享对象。
例如：
~~~c
bufp = Mmap(NULL, size, PROT_READ, MAP_PRIVATE|MAP_ANON, 0, 0);
~~~

让内核创建一个新的包含 size 字节的只读、私有、请求二进制零的虚拟内存区域。如果调用成功，那么 bufp 包含新区域的地址。

`munmap` 函数删除虚拟内存的区域：

~~~c
#include <unistd.h>
#include <sys/mman.h>

int munmap(void *start, size_t length);

// 返回：若成功则为 0，若出错则为 -1。
~~~

`munmap()` 函数删除从虚拟地址 `start` 开始的，由接下来 `length` 字节组成的区域。
接下来对已删除区域的引用会导致段错误。

`munmap()` 函数是 Unix 和类 Unix 系统（如 Linux）中的一个系统调用，用于撤销之前通过 `mmap()` 创建的内存映射。
当一个映射区域不再需要时，应使用 `munmap()` 来*释放资源*。以下是对 `munmap()` 函数的详细介绍：

### 函数原型

```c
#include <sys/mman.h>

int munmap(void *start, size_t length);
```

- **`start`**：指向要撤销的内存映射区域的起始地址。这个地址应该是之前通过 `mmap()` 调用返回的地址。
- **`length`**：要撤销的映射区域的长度，单位是字节。这个长度通常与之前在 `mmap()` 调用中指定的长度相同。

### 返回值

- `munmap()` 成功时返回 `0`。
- 如果出错，则返回 `-1`。在这种情况下，`errno` 被设置为表示错误原因的特定值，例如 `EINVAL` 表示地址或长度不正确。

### 使用场景

- **释放资源**：当通过 `mmap()` 创建的映射区域不再需要时，应使用 `munmap()` 来释放与该映射区域相关的资源，包括内存和文件描述符。
- **内存管理**：在管理复杂的内存映射时，`munmap()` 可以用于撤销无用或已完成任务的映射区域，从而有效管理进程的虚拟地址空间。

### 注意事项

- 确保 `start` 和 `length` 正确：提供给 `munmap()` 的地址和长度应与之前通过 `mmap()` 创建的映射区域完全匹配。不正确的地址或长度可能导致 `munmap()` 失败。
- 映射后的更改：如果映射是 `MAP_SHARED` 类型，并且进行了写操作，那么这些更改在调用 `munmap()` 之前就会反映到文件中。
- 多次映射同一文件：如果同一文件被映射多次，每个映射都应独立地使用 `munmap()` 撤销。

### 示例

以下是一个使用 `munmap()` 的简单示例：

```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("example.txt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    void *map = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0);
    if (map == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }

    // 使用映射区域...

    if (munmap(map, 4096) == -1) {
        perror("munmap");
    }

    close(fd);
    return 0;
}
```

在这个示例中，首先通过 `mmap()` 映射了一个文件，然后在不再需要这个映射时，使用 `munmap()` 来撤销映射。


====================================================================================================
编写一个 C 程序 mmapcopy.c，使用 mmap 将一个任意大小的磁盘文件复制到 stdouto 输入文件的名字必须作为一个命令行参数来传递。

编写一个使用 `mmap` 来复制文件内容到标准输出（stdout）的 C 程序需要几个步骤。
首先，我们需要打开输入文件，然后使用 `mmap` 将其内容映射到内存中。之后，我们可以将映射得到的内存内容写入标准输出。最后，我们需要确保关闭文件并撤销内存映射。

以下是一个名为 `mmapcopy.c` 的示例程序，实现了上述功能：

```c
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

int main(int argc, char *argv[]) {
    int fd;
    struct stat sb;
    char *p;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s <file>\n", argv[0]);
        return 1;
    }

    // 打开文件
    fd = open(argv[1], O_RDONLY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    // 获取文件的属性
    if (fstat(fd, &sb) == -1) {
        perror("fstat");
        close(fd);
        return 1;
    }

    // 将文件映射到内存
    p = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);
    if (p == MAP_FAILED) {
        perror("mmap");
        close(fd);
        return 1;
    }

    // 将文件内容写到标准输出
    if (write(STDOUT_FILENO, p, sb.st_size) != sb.st_size) {
        perror("write");
        munmap(p, sb.st_size);
        close(fd);
        return 1;
    }

    // 清理工作
    munmap(p, sb.st_size);
    close(fd);

    return 0;
}
```

### 使用说明

- 将这段代码保存为 `mmapcopy.c`。
- 使用 `gcc` 编译代码：`gcc -o mmapcopy mmapcopy.c`。
- 运行程序：`./mmapcopy filename`，其中 `filename` 是你想要复制的文件名。

### 程序功能

1. 程序接受一个命令行参数，即要复制的文件名。
2. 它打开指定的文件并获取其大小。
3. 使用 `mmap` 创建一个文件内容的内存映射。
4. 将映射的内容写入标准输出（stdout）。
5. 最后，程序撤销映射并关闭文件。

确保在运行这个程序之前，你有权访问和读取指定的文件。


`struct stat` 是一个在 POSIX 系统（如 Unix、Linux）中定义的结构体，用于存储文件的状态信息。
当你在 C 程序中使用 `stat()`, `fstat()`, 或 `lstat()` 系统调用来获取文件的信息时，这些信息就会被填充到 `struct stat` 类型的变量中。

下面是 `struct stat` 结构体的一般定义（可能在不同系统中略有不同）：

```c
struct stat {
    dev_t     st_dev;     // 文件的设备编号
    ino_t     st_ino;     // inode 号
    mode_t    st_mode;    // 文件的类型和存取的权限
    nlink_t   st_nlink;   // 连到该文件的硬链接数目，刚建立的文件值为1
    uid_t     st_uid;     // 文件所有者的用户识别码
    gid_t     st_gid;     // 文件所有者的组识别码
    dev_t     st_rdev;    // 设备类型，若此文件为设备文件
    off_t     st_size;    // 文件字节数，对普通文件来说是文件数据的大小
    blksize_t st_blksize; // 系统 I/O 的块大小
    blkcnt_t  st_blocks;  // 文件所占的块数
    time_t    st_atime;   // 最后一次访问时间
    time_t    st_mtime;   // 最后一次修改时间
    time_t    st_ctime;   // 最后一次改变时间（指属性）
};
```

当你在代码中声明 `struct stat sb;` 并调用 `stat()`, `fstat()`, 或 `lstat()` 时，这个结构体 `sb` 就会被填充上述相应的文件信息。例如：

- `st_size` 字段表示文件的大小（以字节为单位）。
- `st_mode` 字段表示文件的类型和权限。

在使用这些信息之前，你需要确保 `stat()` 或相关函数调用成功执行。如果调用失败，这些字段的值是未定义的。